# Data Model: AI-Powered Scene Generation

**Feature**: AI-Powered Scene Breakdown Generation
**Date**: 2025-01-05
**Status**: Final

## Overview

This document describes the database schema, TypeScript interfaces, and validation rules for the AI-powered scene breakdown generation feature. All data structures enforce Row Level Security (RLS) for user data isolation per Constitution Principle I.

---

## Database Schema

### Modified Table: `ideas`

The existing `ideas` table is extended to support scene breakdown storage.

```sql
-- Existing structure (from README.md)
CREATE TABLE ideas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users NOT NULL,
  type TEXT NOT NULL,
  type_color TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  category TEXT NOT NULL,
  edited TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL
);

-- NEW: Scene breakdown columns
ALTER TABLE ideas
  ADD COLUMN scene_breakdown TEXT,
  ADD COLUMN scene_breakdown_generated_at TIMESTAMPTZ;
```

**New Fields**:
- `scene_breakdown` (TEXT, nullable): AI-generated or manually edited scene breakdown content
- `scene_breakdown_generated_at` (TIMESTAMPTZ, nullable): Timestamp of last AI generation

**Constraints**:
- `scene_breakdown` maximum length: 65,535 bytes (PostgreSQL TEXT limit)
- `scene_breakdown` can be NULL (manual creation without AI generation)
- `scene_breakdown_generated_at` NULL if manually created (no AI generation)
- `updated_at` automatically updated via trigger on any change (including scene_breakdown edits)

**Indexes** (existing):
- `ideas_created_at_idx` on `created_at DESC`
- `ideas_user_id_idx` on `user_id`

**RLS Policies** (existing):
- `Users can view their own ideas` - SELECT using `auth.uid() = user_id`
- `Users can insert their own ideas` - INSERT with `auth.uid() = user_id`
- `Users can update their own ideas` - UPDATE using `auth.uid() = user_id`
- `Users can delete their own ideas` - DELETE using `auth.uid() = user_id`

---

### New Table: `scene_breakdown_history`

Stores all previous versions of scene breakdowns for unlimited retention (FR-013).

```sql
CREATE TABLE scene_breakdown_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  idea_id BIGINT NOT NULL REFERENCES ideas(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users,
  content TEXT NOT NULL,
  generated_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc', NOW()),
  version INTEGER NOT NULL
);

CREATE INDEX idx_scene_breakdown_history_idea_id
  ON scene_breakdown_history(idea_id, generated_at DESC);

-- Enable Row Level Security
ALTER TABLE scene_breakdown_history ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view their own scene breakdown history"
  ON scene_breakdown_history
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own history"
  ON scene_breakdown_history
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own history"
  ON scene_breakdown_history
  FOR DELETE
  USING (auth.uid() = user_id);
```

**Fields**:
- `id` (BIGINT, PK): Auto-incrementing primary key
- `idea_id` (BIGINT, FK): Foreign key to `ideas.id`, cascade delete on idea deletion
- `user_id` (UUID, FK): Owner of the idea (denormalized for RLS)
- `content` (TEXT, NOT NULL): Full scene breakdown content at this version
- `generated_at` (TIMESTAMPTZ, NOT NULL): When this version was created
- `version` (INTEGER, NOT NULL): Monotonically increasing version number per idea

**Constraints**:
- `idea_id` cascade deletes history when idea is deleted
- `content` maximum length: 65,535 bytes
- `generated_at` defaults to current UTC timestamp
- `version` must be managed application-side (query max version + 1)

**Indexes**:
- `idx_scene_breakdown_history_idea_id`: Composite index on `(idea_id, generated_at DESC)` for efficient history queries

**Validation Rules** (application-level):
- Version must increment by 1 from previous version
- `user_id` must match `ideas.user_id` for the given `idea_id`

---

## Entity Relationships

```
┌─────────────┐         ┌──────────────────────────┐
│   auth      │         │ scene_breakdown_history  │
│   .users    │         │                          │
└─────────────┘         │ id (PK)                  │
                        │ idea_id (FK → ideas.id) │
                        │ user_id (FK → users)     │
                        │ content                  │
                        │ generated_at             │
                        │ version                  │
                        └──────────────────────────┘
                                   │
                                   │ many (history)
                                   │
                                   │ one
                                   │
┌─────────────┐         ┌──────────────────────────┐
│   auth      │    ┌────│         ideas             │
│   .users    │    │    │                          │
└─────────────┘    │    │ id (PK)                  │
                   │    │ user_id (FK → users)     │
                   │    │ type                     │
                   │    │ title                    │
                   │    │ description              │
                   │    │ scene_breakdown (NEW)    │
                   │    │ scene_breakdown_... (NEW)│
                   │    │ created_at               │
                   │    │ updated_at               │
                   │    └──────────────────────────┘
                   │
                   │ one
                   │
                   │ owns
                   │
```

**Relationship Rules**:
1. One `users` → Many `ideas` (existing)
2. One `ideas` → Many `scene_breakdown_history` (new)
3. `ideas.user_id` = `auth.users.id` (RLS enforcement)
4. `scene_breakdown_history.user_id` = `ideas.user_id` (RLS inheritance)

---

## TypeScript Interfaces

### Database Types (Supabase Generated)

After running the migration, regenerate Supabase types:

```bash
npx supabase gen types typescript --project-id YOUR_PROJECT_ID > lib/database.types.ts
```

**Expected Interface** (partial, for scene breakdown fields):

```typescript
// lib/database.types.ts (generated)
export interface Ideas {
  id: number;
  user_id: string;
  type: string;
  type_color: string;
  title: string;
  description: string;
  category: string;
  edited: string;
  scene_breakdown: string | null;
  scene_breakdown_generated_at: string | null; // ISO 8601 timestamp
  created_at: string;
  updated_at: string;
}

export interface SceneBreakdownHistory {
  id: number;
  idea_id: number;
  user_id: string;
  content: string;
  generated_at: string;
  version: number;
}

export interface Tables {
  ideas: Ideas;
  scene_breakdown_history: SceneBreakdownHistory;
}

export interface TablesInsert {
  scene_breakdown_history: {
    id?: number;
    idea_id: number;
    user_id: string;
    content: string;
    generated_at?: string;
    version: number;
  };
}
```

---

### Application Types

```typescript
// lib/types/scene-breakdown.ts

/**
 * Scene breakdown content with metadata
 */
export interface SceneBreakdown {
  content: string; // Sanitized HTML (DOMPurify)
  generatedAt: Date | null; // null if manually created
  isAIGenerated: boolean; // Derived from generatedAt != null
}

/**
 * Scene breakdown history entry
 */
export interface SceneBreakdownVersion {
  id: number;
  ideaId: number;
  content: string;
  generatedAt: Date;
  version: number;
}

/**
 * Generation request parameters
 */
export interface GenerateSceneBreakdownRequest {
  ideaId: number;
  script: string; // From ideas.description or custom field
  language: 'english' | 'indonesian' | 'spanish';
}

/**
 * Generation response (streaming)
 */
export interface GenerateSceneBreakdownResponse {
  stream: ReadableStream<Uint8Array>;
  error?: string;
}

/**
 * Update scene breakdown request
 */
export interface UpdateSceneBreakdownRequest {
  ideaId: number;
  content: string; // New content (will be sanitized)
}

/**
 * Scene breakdown history query result
 */
export interface SceneBreakdownHistory {
  ideaId: number;
  versions: SceneBreakdownVersion[];
  totalVersions: number;
}
```

---

## Zod Validation Schemas

```typescript
// lib/schemas/scene-breakdown.ts
import { z } from 'zod';

/**
 * Script content validation for generation
 */
export const generateSceneBreakdownSchema = z.object({
  ideaId: z.number().int().positive(),
  script: z.string()
    .min(50, 'Script too short (min 50 characters)')
    .max(5000, 'Script too long (max 5000 characters)'),
  language: z.enum(['english', 'indonesian', 'spanish']).default('english'),
});

export type GenerateSceneBreakdownInput = z.infer<typeof generateSceneBreakdownSchema>;

/**
 * Scene breakdown update validation
 */
export const updateSceneBreakdownSchema = z.object({
  ideaId: z.number().int().positive(),
  content: z.string()
    .max(65535, 'Content too large (max 65,535 bytes)')
    .transform((val) => {
      // Sanitize HTML (client-side)
      if (typeof DOMPurify !== 'undefined') {
        return DOMPurify.sanitize(val, {
          ALLOWED_TAGS: ['P', 'BR', 'STRONG', 'EM', 'UL', 'OL', 'LI'],
          ALLOWED_ATTR: [],
        });
      }
      return val;
    }),
});

export type UpdateSceneBreakdownInput = z.infer<typeof updateSceneBreakdownSchema>;

/**
 * Scene breakdown history query validation
 */
export const getSceneBreakdownHistorySchema = z.object({
  ideaId: z.number().int().positive(),
  limit: z.number().int().positive().max(100).default(50),
  offset: z.number().int().nonnegative().default(0),
});

export type GetSceneBreakdownHistoryInput = z.infer<typeof getSceneBreakdownHistorySchema>;
```

---

## Data Access Patterns

### Create Scene Breakdown (AI Generation)

```typescript
async function createSceneBreakdown(
  ideaId: number,
  userId: string,
  content: string
): Promise<void> {
  // 1. Get current version number
  const { data: history } = await supabase
    .from('scene_breakdown_history')
    .select('version')
    .eq('idea_id', ideaId)
    .order('version', { ascending: false })
    .limit(1)
    .single();

  const nextVersion = (history?.version ?? 0) + 1;

  // 2. Save to history (transaction-like)
  const { error: historyError } = await supabase
    .from('scene_breakdown_history')
    .insert({
      idea_id: ideaId,
      user_id: userId,
      content,
      version: nextVersion,
    });

  if (historyError) throw historyError;

  // 3. Update ideas table
  const { error: updateError } = await supabase
    .from('ideas')
    .update({
      scene_breakdown: content,
      scene_breakdown_generated_at: new Date().toISOString(),
    })
    .eq('id', ideaId)
    .eq('user_id', userId); // RLS check

  if (updateError) throw updateError;
}
```

### Update Scene Breakdown (Manual Edit)

```typescript
async function updateSceneBreakdown(
  ideaId: number,
  userId: string,
  content: string
): Promise<void> {
  const { error } = await supabase
    .from('ideas')
    .update({
      scene_breakdown: content,
      // Do NOT update scene_breakdown_generated_at (manual edit)
    })
    .eq('id', ideaId)
    .eq('user_id', userId);

  if (error) throw error;
}
```

### Get Scene Breakdown History

```typescript
async function getSceneBreakdownHistory(
  ideaId: number,
  userId: string,
  limit = 50,
  offset = 0
): Promise<SceneBreakdownVersion[]> {
  const { data, error } = await supabase
    .from('scene_breakdown_history')
    .select('*')
    .eq('idea_id', ideaId)
    .eq('user_id', userId) // RLS check
    .order('generated_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) throw error;
  return data ?? [];
}
```

### Restore from History

```typescript
async function restoreFromHistory(
  ideaId: number,
  userId: string,
  version: number
): Promise<void> {
  // 1. Get history entry
  const { data: historyEntry, error } = await supabase
    .from('scene_breakdown_history')
    .select('content')
    .eq('idea_id', ideaId)
    .eq('user_id', userId)
    .eq('version', version)
    .single();

  if (error || !historyEntry) throw error;

  // 2. Restore to ideas table (do NOT create new history entry)
  const { error: updateError } = await supabase
    .from('ideas')
    .update({
      scene_breakdown: historyEntry.content,
      scene_breakdown_generated_at: null, // Restored, not regenerated
    })
    .eq('id', ideaId)
    .eq('user_id', userId);

  if (updateError) throw updateError;
}
```

---

## Validation Rules Summary

| Field | Type | Constraints | Validation |
|-------|------|-------------|------------|
| `ideas.scene_breakdown` | TEXT | Max 65,535 bytes | Zod max length, DOMPurify sanitization |
| `ideas.scene_breakdown_generated_at` | TIMESTAMPTZ | Optional, ISO 8601 | Zod datetime, nullable |
| `scene_breakdown_history.content` | TEXT | Max 65,535 bytes, NOT NULL | Zod max length, DOMPurify sanitization |
| `scene_breakdown_history.version` | INTEGER | Monotonically increasing | Application-level (max + 1) |
| `scene_breakdown_history.user_id` | UUID | Must match `ideas.user_id` | RLS policy |

---

## Migration Notes

### Step 1: Run Migration

```sql
-- Copy this to Supabase SQL Editor and execute

-- Add columns to ideas table
ALTER TABLE ideas
  ADD COLUMN scene_breakdown TEXT,
  ADD COLUMN scene_breakdown_generated_at TIMESTAMPTZ;

-- Create history table
CREATE TABLE scene_breakdown_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  idea_id BIGINT NOT NULL REFERENCES ideas(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users,
  content TEXT NOT NULL,
  generated_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc', NOW()),
  version INTEGER NOT NULL
);

CREATE INDEX idx_scene_breakdown_history_idea_id
  ON scene_breakdown_history(idea_id, generated_at DESC);

-- Enable RLS
ALTER TABLE scene_breakdown_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own scene breakdown history"
  ON scene_breakdown_history
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own history"
  ON scene_breakdown_history
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own history"
  ON scene_breakdown_history
  FOR DELETE
  USING (auth.uid() = user_id);
```

### Step 2: Regenerate TypeScript Types

```bash
npx supabase gen types typescript --project-id YOUR_PROJECT_ID > lib/database.types.ts
```

### Step 3: Update Application Types

Add interfaces and schemas from this document to `lib/types/scene-breakdown.ts` and `lib/schemas/scene-breakdown.ts`.

### Step 4: Verify RLS Policies

```sql
-- Test RLS policies (run as test user)
SELECT * FROM ideas WHERE id = 1; -- Should return only own ideas
SELECT * FROM scene_breakdown_history WHERE idea_id = 1; -- Should return only own history
```

---

## Rollback Plan

If migration fails or needs to be reverted:

```sql
-- Drop history table
DROP TABLE IF EXISTS scene_breakdown_history CASCADE;

-- Remove columns from ideas table
ALTER TABLE ideas
  DROP COLUMN IF EXISTS scene_breakdown,
  DROP COLUMN IF EXISTS scene_breakdown_generated_at;
```

⚠️ **WARNING**: Rollback will permanently delete all scene breakdown data.
