# Quickstart: AI-Powered Scene Generation

**Feature**: AI-Powered Scene Breakdown Generation
**Audience**: Developers implementing this feature
**Prerequisites**: Next.js 16, Supabase account, OpenAI API key
**Estimated Time**: 2-3 hours

---

## Overview

This guide will help you implement the AI-powered scene breakdown generation feature for Content Memori. The feature allows users to click a sparkles button to automatically generate structured scene analyses from their video scripts using OpenAI.

---

## Prerequisites Checklist

Before starting, ensure you have:

- [ ] Node.js 18+ installed
- [ ] Supabase project set up with existing `ideas` table
- [ ] OpenAI API key ([get one here](https://platform.openai.com/api-keys))
- [ ] Project cloned and dependencies installed (`npm install`)
- [ ] Supabase environment variables configured in `.env.local`

---

## Step 1: Database Migration (15 minutes)

### 1.1 Run SQL Migration

1. Go to your Supabase project dashboard
2. Navigate to **SQL Editor**
3. Create a new query and paste the migration SQL:

```sql
-- Add scene breakdown columns to ideas table
ALTER TABLE ideas
  ADD COLUMN scene_breakdown TEXT,
  ADD COLUMN scene_breakdown_generated_at TIMESTAMPTZ;

-- Create scene breakdown history table
CREATE TABLE scene_breakdown_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  idea_id BIGINT NOT NULL REFERENCES ideas(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users,
  content TEXT NOT NULL,
  generated_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc', NOW()),
  version INTEGER NOT NULL
);

CREATE INDEX idx_scene_breakdown_history_idea_id
  ON scene_breakdown_history(idea_id, generated_at DESC);

-- Enable RLS
ALTER TABLE scene_breakdown_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own scene breakdown history"
  ON scene_breakdown_history
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own history"
  ON scene_breakdown_history
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);
```

4. Click **Run** to execute the migration

### 1.2 Verify Migration

```sql
-- Check new columns exist
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_name = 'ideas'
  AND column_name LIKE 'scene_breakdown%';

-- Check history table exists
SELECT table_name
FROM information_schema.tables
WHERE table_name = 'scene_breakdown_history';
```

Expected output:
```
column_name                      | data_type
---------------------------------|----------
scene_breakdown                  | text
scene_breakdown_generated_at     | timestamp with time zone

table_name
---------------------
scene_breakdown_history
```

---

## Step 2: Environment Configuration (5 minutes)

### 2.1 Add OpenAI API Key

Add to `.env.local`:

```bash
# OpenAI Configuration
OPENAI_API_KEY=sk-your-openai-api-key-here
```

âš ï¸ **IMPORTANT**: Never commit this file to version control. Add `.env.local` to `.gitignore` if not already present.

### 2.2 Verify Environment Variables

```bash
# Load environment variables
source .env.local

# Verify OpenAI key is set
echo $OPENAI_API_KEY
```

Should output: `sk-your-openai-api-key-here`

---

## Step 3: Install Dependencies (5 minutes)

```bash
# Install OpenAI SDK
npm install openai@^4.67.0

# Install DOMPurify for XSS protection
npm install dompurify @types/dompurify

# Install lodash for debounce (or implement custom)
npm install lodash @types/lodash

# Re-generate Supabase types
npx supabase gen types typescript --project-id YOUR_PROJECT_ID > lib/database.types.ts
```

---

## Step 4: Create Core Files (45 minutes)

### 4.1 TypeScript Types

Create `lib/types/scene-breakdown.ts`:

```typescript
export interface SceneBreakdown {
  content: string;
  generatedAt: Date | null;
}

export interface SceneBreakdownVersion {
  id: number;
  ideaId: number;
  content: string;
  generatedAt: Date;
  version: number;
}
```

### 4.2 Zod Validation Schemas

Create `lib/schemas/scene-breakdown.ts`:

```typescript
import { z } from 'zod';

export const generateSceneBreakdownSchema = z.object({
  ideaId: z.number().int().positive(),
  script: z.string().min(50).max(5000),
  language: z.enum(['english', 'indonesian', 'spanish']).default('english'),
});

export const updateSceneBreakdownSchema = z.object({
  ideaId: z.number().int().positive(),
  content: z.string(), // JSON string, validated by parseSceneBreakdown()
});
```

### 4.3 OpenAI Client

Create `lib/openai.ts`:

```typescript
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function generateSceneBreakdown(
  script: string,
  language: string
): Promise<string> {
  const prompt = buildPrompt(script, language);

  const completion = await openai.chat.completions.create({
    model: 'gpt-5-nano',
    messages: [{ role: 'user', content: prompt }],
    temperature: 0.7,
    max_tokens: 2000,
  });

  return completion.choices[0].message.content || '';
}

function buildPrompt(script: string, language: string): string {
  return `You are a professional video director. Generate a scene breakdown for this script in ${language}.

Script:
${script}

Scene Breakdown:`;
}
```

### 4.4 API Route

Create `app/api/generate-scene-breakdown/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { generateSceneBreakdown } from '@/lib/openai';
import { generateSceneBreakdownSchema } from '@/lib/schemas/scene-breakdown';

export const runtime = 'edge';

export async function POST(req: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies });
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await req.json();
    const { ideaId, script, language } = generateSceneBreakdownSchema.parse(body);

    // Verify user owns this idea
    const { data: idea } = await supabase
      .from('ideas')
      .select('id')
      .eq('id', ideaId)
      .eq('user_id', user.id)
      .single();

    if (!idea) {
      return NextResponse.json({ error: 'Idea not found' }, { status: 404 });
    }

    // Generate scene breakdown
    const content = await generateSceneBreakdown(script, language);

    // Get current version number
    const { data: history } = await supabase
      .from('scene_breakdown_history')
      .select('version')
      .eq('idea_id', ideaId)
      .order('version', { ascending: false })
      .limit(1)
      .single();

    const nextVersion = (history?.version ?? 0) + 1;

    // Save to history
    await supabase
      .from('scene_breakdown_history')
      .insert({
        idea_id: ideaId,
        user_id: user.id,
        content,
        version: nextVersion,
      });

    // Update ideas table
    await supabase
      .from('ideas')
      .update({
        scene_breakdown: content,
        scene_breakdown_generated_at: new Date().toISOString(),
      })
      .eq('id', ideaId);

    return NextResponse.json({ success: true, content });
  } catch (error: any) {
    console.error('Generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate scene breakdown' },
      { status: 500 }
    );
  }
}
```

---

## Step 5: Create UI Components (60 minutes)

### 5.1 Scene Breakdown Editor (Client Component)

Create `app/components/scene-breakdown-editor.tsx`:

```tsx
'use client';

import { useState, useEffect } from 'react';
import { Sparkles } from 'lucide-react';
import DOMPurify from 'dompurify';

interface Props {
  ideaId: number;
  initialContent?: string;
  script: string;
}

export function SceneBreakdownEditor({ ideaId, initialContent, script }: Props) {
  const [content, setContent] = useState(initialContent || '');
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleGenerate = async () => {
    setIsGenerating(true);
    setError(null);

    try {
      const response = await fetch('/api/generate-scene-breakdown', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ideaId,
          script,
          language: 'english',
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Generation failed');
      }

      setContent(data.content);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsGenerating(false);
    }
  };

  const handleEdit = (e: React.FormEvent<HTMLDivElement>) => {
    const sanitized = DOMPurify.sanitize(e.currentTarget.innerHTML, {
      ALLOWED_TAGS: ['P', 'BR', 'STRONG', 'EM', 'UL', 'OL', 'LI'],
      ALLOWED_ATTR: [],
    });

    setContent(sanitized);

    // Debounced save
    setTimeout(() => {
      // Implement save logic here
    }, 500);
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">Scene Breakdown</h3>
        <button
          onClick={handleGenerate}
          disabled={isGenerating || !script}
          className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50"
        >
          <Sparkles size={18} />
          {isGenerating ? 'Generating...' : 'Generate Scene Breakdown'}
        </button>
      </div>

      {error && (
        <div className="p-4 bg-red-50 text-red-700 rounded-lg">
          {error}
        </div>
      )}

      <div
        contentEditable
        onInput={handleEdit}
        className="min-h-[300px] p-4 border rounded-lg prose max-w-none focus:outline-none focus:ring-2 focus:ring-purple-500"
        suppressContentEditableWarning
      >
        {content}
      </div>
    </div>
  );
}
```

### 5.2 Integrate into Detail Modal

Update `app/components/detail-modal.tsx` to include the scene breakdown editor:

```tsx
import { SceneBreakdownEditor } from './scene-breakdown-editor';

// In your detail modal JSX, add:
<SceneBreakdownEditor
  ideaId={idea.id}
  initialContent={idea.scene_breakdown}
  script={idea.description} // or whatever field contains the script
/>
```

---

## Step 6: Testing (30 minutes)

### 6.1 Manual Testing

1. **Generate Scene Breakdown**:
   - Open a draft with script content
   - Click the sparkles button
   - Verify loading state appears
   - Wait for generation (should take <15 seconds)
   - Verify scene breakdown content appears

2. **Manual Edit**:
   - Click inside the scene breakdown content
   - Edit text
   - Wait 500ms (auto-save)
   - Refresh page - verify edits persisted

3. **Error Handling**:
   - Try generating without script content (button should be disabled)
   - Try with very long script (>5000 chars) - should show error
   - Disconnect network and try generating - should show error message

4. **RLS Verification**:
   - Create draft as User A
   - Log out and log in as User B
   - Try to access User A's draft - should get 404/403

### 6.2 Real-time Sync Test

1. Open the same draft in two browser windows (same user)
2. Generate scene breakdown in Window 1
3. Verify it appears in Window 2 automatically (Realtime subscription)

---

## Step 7: Deploy (15 minutes)

### 7.1 Environment Variables on Vercel

1. Go to Vercel project settings
2. Add `OPENAI_API_KEY` to environment variables
3. Redeploy the application

### 7.2 Verify Production

```bash
# Build production bundle
npm run build

# Test production build locally
npm start

# Open http://localhost:3000
# Test scene breakdown generation
```

---

## Troubleshooting

### Issue: "Unauthorized" error

**Solution**: Ensure user is logged in. Check Supabase auth session:

```typescript
const { data: { user } } = await supabase.auth.getUser();
console.log('User:', user);
```

### Issue: Generation takes too long (>30s)

**Solution**: Check OpenAI API status, try using `gpt-5-nano` (faster than `gpt-4`):

```typescript
model: 'gpt-5-nano', // Faster, cheaper
```

### Issue: Real-time sync not working

**Solution**: Ensure Realtime is enabled for `ideas` table:

```sql
ALTER PUBLICATION supabase_realtime ADD TABLE ideas;
```

### Issue: XSS vulnerability warning

**Solution**: Ensure DOMPurify is installed and used:

```bash
npm install dompurify @types/dompurify
```

---

## Next Steps

After completing this quickstart:

1. **Add streaming response** for better perceived performance
2. **Implement generation history UI** (User Story 3)
3. **Add language detection** for multilingual support
4. **Write tests** if needed (TDD approach per spec)
5. **Monitor OpenAI API usage** and costs

---

## Additional Resources

- [OpenAI API Documentation](https://platform.openai.com/docs/api-reference)
- [Supabase Realtime Documentation](https://supabase.com/docs/guides/realtime)
- [DOMPurify Documentation](https://github.com/cure53/DOMPurify)
- [Next.js API Routes](https://nextjs.org/docs/api-routes/introduction)

---

## Support

If you encounter issues:

1. Check the feature specification: `spec.md`
2. Review the research document: `research.md`
3. Consult the data model: `data-model.md`
4. Verify API contracts: `contracts/scene-breakdown-api.yaml`

Happy coding! ðŸš€
