# Research: AI-Powered Scene Generation

**Feature**: AI-Powered Scene Breakdown Generation
**Date**: 2025-01-05
**Status**: Complete

## Overview

This document captures research findings and technical decisions for implementing AI-powered scene breakdown generation in the Content Memori application. All unknowns from Technical Context have been resolved.

---

## Decision 1: OpenAI SDK Version

**Question**: Which version of the OpenAI SDK should be used?

**Decision**: OpenAI SDK v4.67.0+ (latest v4.x stable)

**Rationale**:
- v4.x is the current stable major version with TypeScript support
- Compatible with Edge Runtime (required for Next.js API routes)
- Supports async/await patterns for streaming responses
- Well-documented with strong typing for TypeScript strict mode
- Compatible with Node.js 18+ (Next.js 16 requirement)

**Alternatives Considered**:
- **v3.x**: Deprecated, no longer maintained
- **v5.x beta**: Too unstable for production, breaking changes likely
- **Direct REST API**: More manual work, no type safety, harder to maintain

**Implementation Notes**:
```bash
npm install openai@^4.67.0
```

---

## Decision 2: Database Schema for Scene Breakdown

**Question**: How should scene breakdowns and generation history be stored in the existing `ideas` table?

**Decision**:
1. Add `scene_breakdown` TEXT column to `ideas` table (nullable)
2. Add `scene_breakdown_generated_at` TIMESTAMPTZ column (nullable)
3. Create new `scene_breakdown_history` table for unlimited version history

**Rationale**:
- **Single TEXT field** aligns with FR-008 clarification (merged edits, no AI/manual distinction)
- **Separate history table** satisfies FR-013 (unlimited retention) without bloating main table
- **Foreign key to ideas** ensures RLS inheritance (draft owner owns history)
- **TIMESTAMPTZ** for timezone-aware timestamps (existing pattern in database)

**Alternatives Considered**:
- **JSONB for scene breakdown**: Overkill for plain text, harder to query
- **Inline history in ideas table**: Would cause table bloat with unlimited retention
- **Separate `scene_breakdowns` table**: Unnecessary complexity, 1:1 relationship with ideas

**Schema**:
```sql
-- Add to existing ideas table
ALTER TABLE ideas
  ADD COLUMN scene_breakdown TEXT,
  ADD COLUMN scene_breakdown_generated_at TIMESTAMPTZ;

-- New table for generation history
CREATE TABLE scene_breakdown_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  idea_id BIGINT NOT NULL REFERENCES ideas(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users, -- For RLS
  content TEXT NOT NULL,
  generated_at TIMESTAMPTZ NOT NULL DEFAULT TIMEZONE('utc', NOW()),
  version INTEGER NOT NULL
);

CREATE INDEX idx_scene_breakdown_history_idea_id ON scene_breakdown_history(idea_id, generated_at DESC);

-- Enable RLS
ALTER TABLE scene_breakdown_history ENABLE ROW LEVEL SECURITY;

-- RLS Policies (same pattern as ideas table)
CREATE POLICY "Users can view their own scene breakdown history"
  ON scene_breakdown_history
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own history"
  ON scene_breakdown_history
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Trigger for updated_at on ideas (if not exists)
CREATE OR REPLACE FUNCTION handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = TIMEZONE('utc', NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER ideas_updated_at
  BEFORE UPDATE ON ideas
  FOR EACH ROW
  EXECUTE FUNCTION handle_updated_at();
```

---

## Decision 3: Inline Editing Implementation

**Question**: How to implement inline editing for scene breakdown content (FR-014)?

**Decision**: Use `contenteditable` div with debounced auto-save and DOMPurify sanitization

**Rationale**:
- **contenteditable** provides true WYSIWYG editing (native browser API)
- **Debounced auto-save** (500ms) saves on every keystroke pause without spamming API
- **DOMPurify sanitization** prevents XSS attacks from AI-generated or user-edited content
- **Preserves formatting** (line breaks, paragraphs) better than textarea
- **Client Component** boundary only around editor (follows Principle IV)

**Security Critical**: Scene breakdown content comes from AI (untrusted source) and users can edit manually. MUST sanitize to prevent XSS attacks.

**Alternatives Considered**:
- **Textarea**: No rich text, feels less "inline"
- **Modal dialog**: Breaks flow, doesn't match "inline editing" requirement
- **Separate edit page**: Navigation overhead, violates "edit in place" requirement
- **dangerouslySetInnerHTML**: XSS vulnerability (REJECTED)

**Implementation Notes**:
```bash
npm install dompurify @types/dompurify
npm install lodash @types/lodash --save-dev  # or use custom debounce
```

```tsx
'use client'; // Client component for interactivity

import { useState } from 'react';
import DOMPurify from 'dompurify';

export function SceneBreakdownEditor({ initialContent, onSave }) {
  const [value, setValue] = useState(initialContent);
  let saveTimeout: NodeJS.Timeout;

  const handleChange = (e: React.FormEvent<HTMLDivElement>) => {
    // Sanitize on input to prevent XSS
    const sanitized = DOMPurify.sanitize(e.currentTarget.innerHTML, {
      ALLOWED_TAGS: ['P', 'BR', 'STRONG', 'EM', 'UL', 'OL', 'LI'],
      ALLOWED_ATTR: [],
    });
    setValue(sanitized);

    // Debounced auto-save
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
      onSave(sanitized);
    }, 500);
  };

  return (
    <div
      contentEditable
      onInput={handleChange}
      className="prose max-w-none focus:outline-none"
      suppressContentEditableWarning
    >
      {value}
    </div>
  );
}
```

---

## Decision 4: OpenAI API Integration Pattern

**Question**: How to securely integrate OpenAI API without exposing keys?

**Decision**: Next.js API Route (server-side) with environment variable

**Rationale**:
- **API Route** runs server-side (Edge Runtime compatible)
- **Environment variables** never exposed to client (Principle I)
- **Streaming response** for better perceived performance (generates in <15s per SC-001)
- **Error handling** for rate limits, timeouts (FR-009)

**Alternatives Considered**:
- **Client-side OpenAI call**: Security violation (exposes API key)
- **Supabase Edge Function**: Additional infrastructure, not needed
- **Vercel AI SDK**: Overkill, adds dependency for simple use case

**Implementation Notes**:
```typescript
// app/api/generate-scene-breakdown/route.ts
import OpenAI from 'openai';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY, // Server-side only
});

export const runtime = 'edge'; // Edge Runtime for cold start performance

export async function POST(req: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return new Response('Unauthorized', { status: 401 });
  }

  const { script, language } = await req.json();

  // Validate input
  if (!script || script.length > 5000) {
    return new Response('Invalid script', { status: 400 });
  }

  // Language detection and prompt engineering
  const prompt = buildPrompt(script, language);

  try {
    // Streaming generation
    const stream = await openai.chat.completions.create({
      model: 'gpt-5-nano', // Cost-effective, fast
      messages: [{ role: 'user', content: prompt }],
      stream: true,
      timeout: 30000, // 30s max
    });

    // Return streaming response
    return new Response(
      new ReadableStream({
        async start(controller) {
          try {
            for await (const chunk of stream) {
              const text = chunk.choices[0]?.delta?.content || '';
              controller.enqueue(new TextEncoder().encode(text));
            }
          } catch (error) {
            controller.error(error);
          } finally {
            controller.close();
          }
        },
      }),
      {
        headers: {
          'Content-Type': 'text/event-stream',
          'Cache-Control': 'no-cache',
        },
      }
    );
  } catch (error) {
    console.error('OpenAI generation error:', error);
    return new Response(
      JSON.stringify({ error: 'Failed to generate scene breakdown' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
```

---

## Decision 5: Real-time Sync Strategy

**Question**: How to sync scene breakdown changes in real-time (Principle II)?

**Decision**: Supabase Realtime subscription on `ideas` table

**Rationale**:
- **Existing infrastructure**: App already uses Supabase Realtime
- **Automatic updates**: Scene breakdown changes sync to all clients
- **RLS-compliant**: Realtime respects Row Level Security policies
- **Connection pooling**: Handles multiple concurrent users (SC-007)

**Implementation Notes**:
```tsx
// Subscribe to scene breakdown changes
const channel = supabase
  .channel(`idea:${ideaId}:scene-breakdown`)
  .on(
    'postgres_changes',
    {
      event: 'UPDATE',
      schema: 'public',
      table: 'ideas',
      filter: `id=eq.${ideaId}`,
    },
    (payload) => {
      if (payload.new.scene_breakdown !== undefined) {
        setSceneBreakdown(payload.new.scene_breakdown);
      }
    }
  )
  .subscribe();

// Cleanup on unmount
return () => {
  supabase.removeChannel(channel);
};
```

---

## Decision 6: Language Detection Approach

**Question**: How to detect script language for multilingual support (FR-010)?

**Decision**: Simple heuristic-based detection (client-side)

**Rationale**:
- **Fast, no API calls**: Detects in <1ms
- **Sufficient for MVP**: Covers major languages (Indonesian, Spanish, English)
- **Graceful fallback**: Defaults to English if uncertain (Assumption #7)

**Alternatives Considered**:
- **OpenAI language detection**: Extra API call, slower, unnecessary cost
- **Cloud Translation API**: Overkill, violates privacy (sends scripts externally)
- **Library (franc, langdetect)**: Additional dependency, not needed

**Implementation**:
```typescript
function detectLanguage(text: string): string {
  // Simple keyword matching
  const indonesianKeywords = ['yang', 'dan', 'untuk', 'adalah', 'dengan'];
  const spanishKeywords = ['el', 'la', 'de', 'que', 'y', 'en'];

  const lowerText = text.toLowerCase();

  const indoCount = indonesianKeywords.filter(kw => lowerText.includes(kw)).length;
  const spanishCount = spanishKeywords.filter(kw => lowerText.includes(kw)).length;

  if (indoCount >= 2) return 'indonesian';
  if (spanishCount >= 2) return 'spanish';
  return 'english'; // Default
}
```

---

## Decision 7: Prompt Engineering for Scene Breakdown

**Question**: What prompt structure produces high-quality scene breakdowns?

**Decision**: Structured few-shot prompt with scene numbering

**Rationale**:
- **Few-shot examples**: Guide model to expected output format
- **Scene numbering**: Organized, structured output (Assumption #1)
- **Camera angles & visual cues**: Specific requirements from spec
- **Language matching**: Prompt in same language as script

**Prompt Template**:
```typescript
function buildPrompt(script: string, language: string): string {
  const languageInstructions = {
    english: 'Generate the scene breakdown in English',
    indonesian: 'Generate the scene breakdown in Indonesian',
    spanish: 'Generate the scene breakdown in Spanish',
  };

  return `You are a professional video director and cinematographer. Generate a detailed scene breakdown for the following script.

${languageInstructions[language] || languageInstructions.english}

**Requirements**:
- Number each scene (Scene 1, Scene 2, etc.)
- Describe visual elements (setting, lighting, props)
- Specify camera angles (wide shot, close-up, over-the-shoulder, etc.)
- Identify key action moments and transitions
- Keep descriptions concise but clear (2-3 sentences per scene)

**Script**:
${script}

**Scene Breakdown**:
`;
}
```

---

## Decision 8: Error Handling & Retry Strategy

**Question**: How to handle AI service failures (FR-005, FR-009)?

**Decision**: Exponential backoff with user-friendly error messages

**Rationale**:
- **Exponential backoff**: Handles rate limits gracefully (standard OpenAI pattern)
- **Timeout after 30s**: Prevents hanging (SC-001 requires <15s, 30s safety margin)
- **Manual editing fallback**: Users can still create scene breakdowns manually (FR-015)
- **Specific error messages**: Helps users understand what went wrong

**Implementation**:
```typescript
async function generateWithRetry(script: string, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await openai.chat.completions.create({
        model: 'gpt-5-nano',
        messages: [{ role: 'user', content: script }],
        timeout: 30000, // 30s
      });
    } catch (error: any) {
      if (error.status === 429) {
        // Rate limited - wait and retry
        const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
        await new Promise(resolve => setTimeout(resolve, delay));
      } else if (error.status >= 500 || error.code === 'ECONNRESET') {
        // Server error or network issue - retry
        if (attempt === maxRetries - 1) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000));
      } else {
        // Client error (4xx) - don't retry
        throw error;
      }
    }
  }
}
```

---

## Decision 9: Icon Selection (Sparkles)

**Question**: Which Lucide React icon for the sparkles button (FR-001)?

**Decision**: `Sparkles` icon from Lucide React

**Rationale**:
- **Exact match**: User specified "spark spark icon" (matches feature description)
- **Available in Lucide**: Already installed in project (0.454.0)
- **Clear semantics**: Universally understood as "AI" or "magic" action
- **Consistent size**: 16-20px, scales well

**Implementation**:
```tsx
import { Sparkles } from 'lucide-react';

<button className="flex items-center gap-2">
  <Sparkles size={18} />
  Generate Scene Breakdown
</button>
```

---

## Summary of Decisions

| Decision | Choice | Key Benefit |
|----------|--------|-------------|
| OpenAI SDK | v4.67.0+ | TypeScript support, Edge Runtime compatible |
| Scene Storage | TEXT column + history table | Simple, efficient, unlimited retention |
| Inline Editing | contenteditable + DOMPurify | True WYSIWYG, XSS-safe |
| API Pattern | Next.js API Route | Server-side security, streaming |
| Real-time Sync | Supabase Realtime | Existing infra, RLS-compliant |
| Language Detection | Heuristic keyword matching | Fast, no API calls, sufficient |
| Prompt Engineering | Few-shot structured prompt | High-quality output, language-aware |
| Error Handling | Exponential backoff | Handles rate limits, timeouts |
| Icon | Lucide Sparkles | User requirement, already installed |

---

## Next Steps

With research complete, proceed to **Phase 1: Design & Contracts**:
1. Create `data-model.md` with entity definitions
2. Generate API contracts in `contracts/scene-breakdown-api.yaml`
3. Create `quickstart.md` for developers
4. Update agent-specific context files

All technical unknowns resolved. Ready for detailed design phase.
